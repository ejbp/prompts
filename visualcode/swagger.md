Enforce the response envelopes everywhere: every controller method must return either { data: … } or { data: items, pagination: … }, or { error: … }. If the handler naturally returns another shape, wrap it before exiting (e.g., list endpoints return { items, pagination } so the global interceptor can convert to { data, pagination } cleanly).
Use shared decorators from swagger.decorators.ts: @ApiDataResponse(MyDto) for single payloads, @ApiListResponse(MyDto) for arrays, and @ApiErrorResponse(status, { description?, exampleMessage? }) for each failure path. Apply them on every route (public, private, internal, webhook) so Swagger describes both success and error envelopes.
Back every response with a DTO that mirrors the exact shape the handler returns (e.g., ProjectViewDto, MountViewDto, GithubRepositoryListDto, BridgeTicketDto). Annotate fields with @ApiProperty (enum links, nullable flags, example values) and place DTOs under the module’s dto/ folder to keep things organized.
When an endpoint returns a simple { ok: true } or { deleted: true }, create tiny DTOs (OkResponseDto, ProjectDeletedResponseDto) instead of inline schemas so they can be reused.
For list endpoints, convert raw arrays to { items, pagination } in the controller itself (derive a simple count-based pagination object) before returning; this ensures both Swagger and runtime stay consistent with the global ResponseEnvelopeInterceptor.
Keep public/consumer controllers (github, projects, instances, etc.) using @ApiTags('private'|'public'), and don’t forget internal ones—they require the same decorators so Swagger shows complete coverage.
After decorating, run npm run build to ensure the Nest compiler picks up the DTOs (they must be referenced/imported to avoid tree-shaking).